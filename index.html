<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Software Engineering Infographics</title>
<style>
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0;
      background: #f4f6f8;
      color: #333;
    }
    header {
      background: #1e2a38;
      color: white;
      padding: 2rem 1rem;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    nav {
      margin-top: 1.5rem;
    }
    .about-btn {
      display: inline-block;
      padding: 0.8rem 2rem;
      background: linear-gradient(135deg, #3289c6 0%, #299dc4 100%);
      color: white;
      text-decoration: none;
      border-radius: 25px;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
      border: none;
      cursor: pointer;
    }
    .about-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
      background: linear-gradient(135deg, #0099cc 0%, #00d4ff 100%);
    }
    .about-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
    }
    .container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
      padding: 2rem;
      max-width: 1200px;
      margin: auto;
    }
    .card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      cursor: pointer;
    }
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    }
    .icon {
      width: 64px;
      height: 64px;
      margin-bottom: 1rem;
    }
    .title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #1e2a38;
      text-align: center;
    }
    .description {
      font-size: 0.95rem;
      color: #555;
      text-align: center;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    .modal h2 {
      margin-top: 0;
    }
    .modal ul li {
      margin-bottom: 0.4rem;
    }
    .close {
      float: right;
      font-size: 1.2rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
<header>
<h1>Software Engineering Concepts Infographics</h1>
<p>A quick reference cheatsheet for essential software engineering concepts and principles</p>
<nav>
  <a href="about.html" class="about-btn">👨🏻‍💻 About Me 🇸🇬</a>
</nav>
</header>
<main class="container" id="card-container"></main>
<div class="modal" id="modal">
<div class="modal-content">
<span class="close" onclick="closeModal()">×</span>
<div id="modal-body"></div>
</div>
</div>
<script>
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modal-body');

    const concepts = [
  {
    "id": "encapsulation",
    "title": "Encapsulation",
    "icon": "https://img.icons8.com/?size=100&id=hBExduFpnYNx&format=png&color=000000",
    "description": "Bundling data (attributes) and methods (functions) that operate on that data within a class, and restricting direct access to some of the object's components.",
    "example": "Example: A class with private fields and public getters/setters.",
    "anti-pattern": "Anti-pattern: Exposing internal state directly without methods.",
    "pros": ["Improves modularity", "Protects internal state", "Eases maintenance"],
    "cons": ["Can add boilerplate code", "May reduce flexibility if overused"],
    "details": `<h2>Encapsulation</h2>
      <p>Encapsulation is the practice of bundling data (attributes) and methods (functions) that operate on that data within a class, and restricting direct access to some of the object's components.</p>
      <ul><li><strong>✅ Example:</strong> A class with private fields and public getters/setters.</li>
      <li><strong>❌ Anti-pattern:</strong> Exposing internal state directly without methods.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves modularity</li><li>👍🏻 Protects internal state</li><li>👍🏻 Eases maintenance</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can add boilerplate code</li><li>👎🏻 May reduce flexibility if overused</li></ul>`
  },
  {
    "id": "polymorphism",
    "title": "Polymorphism",
    "icon": "https://img.icons8.com/?size=100&id=12157&format=png&color=000000",
    "description": "Polymorphism is the ability for objects of different classes to be treated as the same type, with the actual behavior of a function call determined by the specific class of the object passed in at runtime.",
    "anti-pattern": "Anti-pattern: Using type checks and manual dispatch instead of polymorphism.",
    "pros": ["Enables code reuse", "Simplifies code extension", "Supports flexible design"],
    "cons": ["Can make code harder to trace", "May introduce runtime errors if misused"],
    "details": `<h2>Polymorphism</h2>
      <p>Polymorphism is the ability in object-oriented programming (OOP) for different classes to be treated as instances of the same interface or parent class, allowing for method behavior to be determined dynamically based on the object's actual class.</p>
      <ul><li><strong>✅ Example:</strong> <br>
      <em>Animal</em> is an interface (or abstract class) with a <code>speak()</code> method. <em>Cat</em> and <em>Dog</em> are classes that implement the <em>Animal</em> interface and provide their own implementation of <code>speak()</code>.<br>
      A function <code>makeItSpeak(animal: Animal)</code> can accept either a <code>Cat</code> or <code>Dog</code> object at runtime, and will call the correct <code>speak()</code> method depending on the actual object passed in.<br>
      </li>
      <li><strong>❌ Anti-pattern:</strong> Using type checks and manual dispatch instead of polymorphism.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables code reuse</li><li>👍🏻 Simplifies code extension</li><li>👍🏻 Supports flexible design</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can make code harder to trace</li><li>👎🏻 May introduce runtime errors if misused</li></ul>`
  },
  {
    "id": "solidprinciples",
    "title": "SOLID Principles",
    "icon": "https://img.icons8.com/?size=100&id=12817&format=png&color=000000",
    "description": "Five fundamental principles for object-oriented programming and design that promote maintainable, flexible, and robust software architecture. These principles help developers write code that is easier to understand, modify, and extend.",
    "anti-pattern": "Anti-pattern: Writing monolithic classes that violate multiple SOLID principles, leading to tightly coupled, hard-to-maintain code.",
    "pros": ["Improves maintainability and readability", "Encourages separation of concerns and modularity", "Facilitates testing and debugging", "Reduces code duplication", "Makes code more flexible and extensible"],
    "cons": ["Can increase initial code complexity and development time", "May require more classes and interfaces", "Can lead to over-engineering if applied unnecessarily"],
    "details": `<h2>SOLID Principles</h2>
      <p>The SOLID principles are five fundamental design principles for object-oriented programming that promote maintainable, flexible, and robust software architecture. These principles, introduced by Robert C. Martin, help developers create code that is easier to understand, modify, and extend over time.</p>
      <ul><li><strong>✅ Example:</strong> A well-architected e-commerce system where each class has a single responsibility (SRP), payment processors can be extended without modification (OCP), different payment types are interchangeable (LSP), interfaces are focused and specific (ISP), and high-level modules depend on abstractions rather than concrete implementations (DIP).</li>
      <li><strong>❌ Anti-pattern:</strong> A monolithic 'OrderManager' class that handles order creation, payment processing, inventory management, email notifications, and logging - violating multiple SOLID principles and creating a maintenance nightmare.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves maintainability and readability</li><li>👍🏻 Encourages separation of concerns and modularity</li><li>👍🏻 Facilitates testing and debugging</li><li>👍🏻 Reduces code duplication</li><li>👍🏻 Makes code more flexible and extensible</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can increase initial code complexity and development time</li><li>👎🏻 May require more classes and interfaces</li><li>👎🏻 Can lead to over-engineering if applied unnecessarily</li></ul>`
  },
  {
    "id": "captheorem",
    "title": "CAP Theorem",
    "icon": "https://img.icons8.com/?size=100&id=12025&format=png&color=000000",
    "description": "In distributed systems, you can only guarantee two of: Consistency, Availability, Partition Tolerance. Example: CP system sacrifices availability during network partition.",
    "anti-pattern": "Anti-pattern: Assuming a distributed system can guarantee all three properties at once.",
    "pros": ["Clarifies trade-offs in distributed systems", "Guides architecture decisions"],
    "cons": ["Can oversimplify real-world systems", "Not all systems fit neatly into CAP categories"],
    "details": `<h2>CAP Theorem</h2>
      <p>In distributed systems, you can only guarantee two of: Consistency, Availability, Partition Tolerance.</p>
      <ul><li><strong>✅ Example:</strong> CP system sacrifices availability during network partition.</li>
      <li><strong>❌ Anti-pattern:</strong> Assuming a distributed system can guarantee all three properties at once.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Clarifies trade-offs in distributed systems</li><li>👍🏻 Guides architecture decisions</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can oversimplify real-world systems</li><li>👎🏻 Not all systems fit neatly into CAP categories</li></ul>`
  },
  {
    "id": "inheritance",
    "title": "Inheritance",
    "icon": "https://img.icons8.com/?size=100&id=DkpYfYRyotRl&format=png&color=000000",
    "description": "Mechanism to derive new classes from existing ones. Example: `class Car extends Vehicle {}` inherits attributes and methods.",
    "anti-pattern": "Anti-pattern: Copy-pasting code instead of using inheritance.",
    "pros": ["Promotes code reuse", "Simplifies extension of functionality"],
    "cons": ["Can lead to tight coupling", "May cause fragile base class problem"],
    "details": `<h2>Inheritance</h2>
      <p>Mechanism to derive new classes from existing ones.</p>
      <ul><li><strong>✅ Example:</strong> class Car extends Vehicle {} inherits attributes and methods.</li>
      <li><strong>❌ Anti-pattern:</strong> Copy-pasting code instead of using inheritance.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Promotes code reuse</li><li>👍🏻 Simplifies extension of functionality</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can lead to tight coupling</li><li>👎🏻 May cause fragile base class problem</li></ul>`
  },
  {
    "id": "microservices",
    "title": "Microservices",
    "icon": "https://img.icons8.com/?size=100&id=13052&format=png&color=000000",
    "description": "Architectural style that structures an app as a collection of loosely coupled services. Example: User service, order service, and payment service communicate via REST.",
    "anti-pattern": "Anti-pattern: A monolithic application where all logic is in a single codebase.",
    "pros": ["Enables independent deployment", "Improves scalability", "Facilitates technology diversity"],
    "cons": ["Increases operational complexity", "Requires robust inter-service communication", "Can lead to data consistency challenges"],
    "details": `<h2>Microservices</h2>
      <p>Architectural style that structures an app as a collection of loosely coupled services.</p>
      <ul><li><strong>✅ Example:</strong> User service, order service, and payment service communicate via REST.</li>
      <li><strong>❌ Anti-pattern:</strong> A monolithic application where all logic is in a single codebase.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables independent deployment</li><li>👍🏻 Improves scalability</li><li>👍🏻 Facilitates technology diversity</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Increases operational complexity</li><li>👎🏻 Requires robust inter-service communication</li><li>👎🏻 Can lead to data consistency challenges</li></ul>`
  },
  {
    "id": "domaindrivendesignddd",
    "title": "Domain-Driven Design (DDD)",
    "icon": "https://img.icons8.com/?size=100&id=12289&format=png&color=000000",
    "description": "Focuses on modeling software to match a domain's logic. Example: Bounded Contexts and Ubiquitous Language in large applications.",
    "anti-pattern": "Anti-pattern: Designing software without input from domain experts.",
    "pros": ["Aligns software with business needs", "Improves communication between developers and stakeholders"],
    "cons": ["Can be complex to implement", "Requires significant domain knowledge"],
    "details": `<h2>Domain-Driven Design (DDD)</h2>
      <p>Focuses on modeling software to match a domain's logic.</p>
      <ul><li><strong>✅ Example:</strong> Bounded Contexts and Ubiquitous Language in large applications.</li>
      <li><strong>❌ Anti-pattern:</strong> Designing software without input from domain experts.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Aligns software with business needs</li><li>👍🏻 Improves communication between developers and stakeholders</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can be complex to implement</li><li>👎🏻 Requires significant domain knowledge</li></ul>`
  }
];

    const solidPrinciples = [
  {
    id: "srp",
    title: "Single Responsibility Principle (SRP)",
    description: "A class should have only one reason to change, meaning it should have only one job or responsibility. This principle ensures that a class is focused on a single concern, making it easier to understand, test, and maintain.",
    example: "A 'UserEmailService' class that only handles sending emails to users. It doesn't manage user data, validate user input, or handle authentication - it has one clear responsibility: email communication.",
    counterExample: "A 'User' class that handles user data storage, email sending, password validation, logging, and file operations - having multiple reasons to change and multiple responsibilities.",
    pros: ["Easier to understand and maintain", "Improves code readability and organization", "Reduces the impact of changes", "Facilitates unit testing", "Promotes code reusability"],
    cons: ["May lead to more classes in the system", "Can sometimes be challenging to identify the 'single responsibility'", "Might increase initial development complexity"]
  },
  {
    id: "ocp",
    title: "Open/Closed Principle (OCP)",
    description: "Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code, typically achieved through inheritance, interfaces, or composition.",
    example: "A 'PaymentProcessor' abstract class with concrete implementations like 'CreditCardProcessor', 'PayPalProcessor', and 'CryptoProcessor'. Adding a new payment method (like 'ApplePayProcessor') doesn't require modifying existing payment classes.",
    counterExample: "A 'PaymentProcessor' class with a large switch statement that needs to be modified every time a new payment method is added, requiring changes to existing, tested code.",
    pros: ["Facilitates code extension without breaking existing functionality", "Reduces risk of introducing bugs in existing code", "Promotes loose coupling", "Supports the addition of new features safely", "Encourages the use of abstraction"],
    cons: ["Can require more abstraction and planning upfront", "May lead to more complex inheritance hierarchies", "Can be over-engineered if future requirements are unclear"]
  },
  {
    id: "lsp",
    title: "Liskov Substitution Principle (LSP)",
    description: "Subtypes must be substitutable for their base types without breaking the program. It means that objects of a superclass should be replaceable with objects of a subclass without breaking the application's functionality or violating expected behavior.",
    example: "A 'Bird' base class with a 'fly()' method, where 'Eagle' and 'Sparrow' subclasses can be used interchangeably anywhere a 'Bird' is expected, both implementing 'fly()' appropriately for their type without breaking the program's logic.",
    counterExample: "A 'Bird' base class with 'Penguin' subclass that throws an exception when 'fly()' is called, violating the expected behavior and breaking substitutability.",
    pros: ["Ensures correct inheritance design", "Prevents unexpected behavior when using polymorphism", "Maintains program correctness", "Enables reliable code reuse", "Supports robust object-oriented design"],
    cons: ["Can be subtle and difficult to enforce", "May require careful design of base class contracts", "Can limit flexibility in some inheritance scenarios"]
  },
  {
    id: "isp",
    title: "Interface Segregation Principle (ISP)",
    description: "Clients should not be forced to depend on interfaces they do not use. This principle advocates for creating specific, focused interfaces rather than large, monolithic ones. Classes should only implement the methods they actually need.",
    example: "Instead of one large 'Bird' interface with methods like 'fly()', 'swim()', and 'layEggs()', create separate interfaces: 'Flyable' with 'fly()', 'Swimmable' with 'swim()', and 'EggLayer' with 'layEggs()'. An 'Eagle' class implements 'Flyable' and 'EggLayer', while an 'Ostrich' class only implements 'EggLayer' (since ostriches can't fly or swim well).",
    counterExample: "A large 'Bird' interface that forces an 'Ostrich' class to implement unused methods like 'fly()' and 'swim()', typically resulting in empty implementations or thrown exceptions since ostriches cannot fly or swim effectively.",
    pros: ["Reduces unnecessary dependencies", "Improves code flexibility and maintainability", "Makes interfaces more focused and cohesive", "Enables better testability", "Prevents interface pollution"],
    cons: ["May result in more interfaces to manage", "Can increase the number of dependencies", "Requires careful interface design planning"]
  },
  {
    id: "dip",
    title: "Dependency Inversion Principle (DIP)",
    description: "High-level modules should not depend on low-level modules. Both should depend on abstractions (interfaces or abstract classes). Additionally, abstractions should not depend on details; details should depend on abstractions. This principle promotes loose coupling and makes systems more flexible and testable.",
    example: "An 'OrderService' class depends on an 'IPaymentProcessor' interface rather than a concrete 'CreditCardProcessor' class. The payment processor implementation is injected, allowing easy switching between different payment methods without changing the OrderService code.",
    counterExample: "An 'OrderService' class that directly instantiates and uses a 'CreditCardProcessor' class, creating tight coupling and making it difficult to test or switch to different payment processors.",
    pros: ["Improves testability through dependency injection", "Reduces coupling between modules", "Increases flexibility and extensibility", "Makes code more modular and maintainable", "Enables easier mocking for unit tests"],
    cons: ["Can add complexity to the system architecture", "May require dependency injection frameworks", "Can make code harder to follow for beginners", "Requires more upfront design consideration"]
  }
];

    const dddSubtopics = [
  {
    id: "bounded-context",
    title: "Bounded Context",
    description: "A boundary within which a particular domain model is defined and applicable.",
    example: "User and Order are separate bounded contexts in an e-commerce system.",
    counterExample: "Mixing unrelated models and logic in a single context.",
    pros: ["Reduces ambiguity", "Enables independent development"],
    cons: ["Requires clear boundaries", "Can add integration complexity"]
  },
  {
    id: "ubiquitous-language",
    title: "Ubiquitous Language",
    description: "A common language used by both developers and domain experts to describe the domain.",
    example: "Using the same terms for concepts in code and business discussions.",
    counterExample: "Developers and business use different terms for the same concept.",
    pros: ["Improves communication", "Reduces misunderstandings"],
    cons: ["Requires discipline to maintain"]
  },
  {
    id: "entity",
    title: "Entity",
    description: "An object defined primarily by its identity, not its attributes.",
    example: "A Customer object with a unique ID.",
    counterExample: "Treating objects with no unique identity as entities.",
    pros: ["Tracks changes over time", "Supports complex domains"],
    cons: ["Can be overused for simple data"]
  },
  {
    id: "value-object",
    title: "Value Object",
    description: "An object defined by its attributes, not its identity.",
    example: "An Address object with street, city, and zip code.",
    counterExample: "Assigning unique IDs to value objects.",
    pros: ["Immutable", "Easier to reason about"],
    cons: ["May require copying for changes"]
  },
  {
    id: "aggregate",
    title: "Aggregate",
    description: "A cluster of domain objects treated as a single unit for data changes.",
    example: "Order aggregate includes Order and OrderItems.",
    counterExample: "Allowing external objects to modify aggregate internals directly.",
    pros: ["Enforces consistency", "Defines clear ownership"],
    cons: ["Can be complex to design"]
  },
  {
    id: "repository",
    title: "Repository",
    description: "A mechanism for encapsulating storage, retrieval, and search behavior.",
    example: "OrderRepository handles saving and retrieving Order aggregates.",
    counterExample: "Directly accessing the database from domain logic.",
    pros: ["Decouples domain from data access", "Improves testability"],
    cons: ["Adds abstraction layer"]
  }
];

    function renderCards() {
      const container = document.getElementById('card-container');
      container.innerHTML = concepts.map(c => `
        <div class="card" onclick="showModal('${c.id}')">
          <img class="icon" src="${c.icon}" alt="${c.title}" />
          <div class="title">${c.title}</div>
          <div class="description">${c.description.replace(/\n/g, '<br>')}</div>
        </div>`).join('');
    }

    function showSolidPrincipleModal(principleId) {
  const p = solidPrinciples.find(x => x.id === principleId);
  if (p) {
    modalBody.innerHTML = `
      <h2>${p.title}</h2>
      <p>${p.description}</p>
      <ul><li><strong>✅ Example:</strong> ${p.example}</li>
      <li><strong>❌ Anti-pattern:</strong> ${p.counterExample}</li></ul>
      <strong>Pros:</strong><ul>${p.pros.map(pr => `<li>👍🏻 ${pr}</li>`).join('')}</ul>
      <strong>Cons:</strong><ul>${p.cons.map(co => `<li>👎🏻 ${co}</li>`).join('')}</ul>
      <button onclick="showModal('solidprinciples')">Back to SOLID Principles</button>
    `;
    modal.style.display = 'flex';
  }
}

    function showDDDSubtopicModal(subtopicId) {
  const s = dddSubtopics.find(x => x.id === subtopicId);
  if (s) {
    modalBody.innerHTML = `
      <h2>${s.title}</h2>
      <p>${s.description}</p>
      <ul><li><strong>✅ Example:</strong> ${s.example}</li>
      <li><strong>❌ Anti-pattern:</strong> ${s.counterExample}</li></ul>
      <strong>Pros:</strong><ul>${s.pros.map(pr => `<li>👍🏻 ${pr}</li>`).join('')}</ul>
      <strong>Cons:</strong><ul>${s.cons.map(co => `<li>👎🏻 ${co}</li>`).join('')}</ul>
      <button onclick=\"showModal('domaindrivendesignddd')\">Back to DDD</button>
    `;
    modal.style.display = 'flex';
  }
}

    function showModal(id) {
      if (id === 'solidprinciples') {
        modalBody.innerHTML = `
      <h2>SOLID Principles</h2>
      <p>Five principles for maintainable OOP: SRP, OCP, LSP, ISP, DIP.</p>
      <ul>
        <li><a href="#" onclick="showSolidPrincipleModal('srp');return false;">Single Responsibility Principle (SRP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('ocp');return false;">Open/Closed Principle (OCP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('lsp');return false;">Liskov Substitution Principle (LSP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('isp');return false;">Interface Segregation Principle (ISP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('dip');return false;">Dependency Inversion Principle (DIP)</a></li>
      </ul>
    `;
        modal.style.display = 'flex';
        return;
      }
      if (id === 'domaindrivendesignddd') {
        modalBody.innerHTML = `
      <h2>Domain-Driven Design (DDD)</h2>
      <p>Focuses on modeling software to match a domain's logic. Key subtopics:</p>
      <ul>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('bounded-context');return false;\">Bounded Context</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('ubiquitous-language');return false;\">Ubiquitous Language</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('entity');return false;\">Entity</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('value-object');return false;\">Value Object</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('aggregate');return false;\">Aggregate</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('repository');return false;\">Repository</a></li>
      </ul>
    `;
        modal.style.display = 'flex';
        return;
      }
      const concept = concepts.find(c => c.id === id);
      if (concept) {
        modalBody.innerHTML = concept.details;
        modal.style.display = 'flex';
      }
    }

    function closeModal() {
      modal.style.display = 'none';
    }

    window.onclick = function(event) {
      if (event.target === modal) {
        closeModal();
      }
    }

    renderCards();
  </script>
</body>
</html>
