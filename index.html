<!DOCTYPE html>

<html lang="en">
<head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<title>Software Engineering Infographics</title>
<style>
    * {
      box-sizing: border-box;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    }
    body {
      margin: 0;
      background: #f4f6f8;
      color: #333;
    }
    header {
      background: #1e2a38;
      color: white;
      padding: 2rem 1rem;
      text-align: center;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    nav {
      margin-top: 1.5rem;
    }
    .about-btn {
      display: inline-block;
      padding: 0.8rem 2rem;
      background: linear-gradient(135deg, #3289c6 0%, #299dc4 100%);
      color: white;
      text-decoration: none;
      border-radius: 25px;
      font-weight: 600;
      font-size: 1rem;
      transition: all 0.3s ease;
      box-shadow: 0 4px 15px rgba(0, 212, 255, 0.3);
      border: none;
      cursor: pointer;
    }
    .about-btn:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(0, 212, 255, 0.4);
      background: linear-gradient(135deg, #0099cc 0%, #00d4ff 100%);
    }
    .about-btn:active {
      transform: translateY(0);
      box-shadow: 0 2px 10px rgba(0, 212, 255, 0.3);
    }
    .container {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
      gap: 1.5rem;
      padding: 2rem;
      max-width: 1200px;
      margin: auto;
    }
    .card {
      background: white;
      border-radius: 12px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
      padding: 1.5rem;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      cursor: pointer;
    }
    .card:hover {
      transform: translateY(-5px);
      box-shadow: 0 6px 20px rgba(0, 0, 0, 0.1);
    }
    .icon {
      width: 64px;
      height: 64px;
      margin-bottom: 1rem;
    }
    .title {
      font-size: 1.2rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      color: #1e2a38;
      text-align: center;
    }
    .description {
      font-size: 0.95rem;
      color: #555;
      text-align: center;
    }
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0, 0, 0, 0.6);
      justify-content: center;
      align-items: center;
      z-index: 1000;
    }
    .modal-content {
      background: white;
      padding: 2rem;
      border-radius: 8px;
      width: 90%;
      max-width: 600px;
      max-height: 90vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
    }
    .modal h2 {
      margin-top: 0;
    }
    .modal ul li {
      margin-bottom: 0.4rem;
    }
    .close {
      float: right;
      font-size: 1.2rem;
      cursor: pointer;
    }
  </style>
</head>
<body>
<header>
<h1>Software Engineering Concepts Infographics</h1>
<p>A quick reference cheatsheet for essential software engineering concepts and principles</p>
<nav>
  <a href="about.html" class="about-btn">👨🏻‍💻 About Me 🇸🇬</a>
</nav>
</header>
<main class="container" id="card-container"></main>
<div class="modal" id="modal">
<div class="modal-content">
<span class="close" onclick="closeModal()">×</span>
<div id="modal-body"></div>
</div>
</div>
<footer style="text-align:center; padding:1.5rem 0; background:#f4f6f8; color:#888; font-size:0.95rem;">
  <div>Page visits:</div>
  <!-- Statcounter code for Portfolio Site https://qooooo.github.io/ -->
  <script type="text/javascript">
    var sc_project=13150355; 
    var sc_invisible=0; 
    var sc_security="2915488c"; 
    var scJsHost = "https://";
    document.write("<sc"+"ript type='text/javascript' src='" + scJsHost+ "statcounter.com/counter/counter.js'></"+"script>");
  </script>
  <noscript>
    <div class="statcounter">
      <a title="Web Analytics"
        href="https://statcounter.com/" target="_blank"><img class="statcounter"
        src="https://c.statcounter.com/13150355/0/2915488c/0/" alt="Web Analytics"
        referrerPolicy="no-referrer-when-downgrade">
      </a>
    </div>
  </noscript>
  <!-- End of Statcounter Code -->
</footer>
<script>
    const modal = document.getElementById('modal');
    const modalBody = document.getElementById('modal-body');

    const concepts = [
  {
    "id": "encapsulation",
    "title": "Encapsulation",
    "icon": "https://img.icons8.com/?size=100&id=hBExduFpnYNx&format=png&color=000000",
    "description": "Bundling data (attributes) and methods (functions) that operate on that data within a class, and restricting direct access to some of the object's components.",
    "example": "Example: A class with private fields and public getters/setters.",
    "anti-pattern": "Anti-pattern: Exposing internal state directly without methods.",
    "pros": ["Improves modularity", "Protects internal state", "Eases maintenance"],
    "cons": ["Can add boilerplate code", "May reduce flexibility if overused"],
    "details": `<h2>Encapsulation</h2>
      <p>Encapsulation is the practice of bundling data (attributes) and methods (functions) that operate on that data within a class, and restricting direct access to some of the object's components.</p>
      <ul><li><strong>✅ Example:</strong> A class with private fields and public getters/setters.</li>
      <li><strong>❌ Anti-pattern:</strong> Exposing internal state directly without methods.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves modularity</li><li>👍🏻 Protects internal state</li><li>👍🏻 Eases maintenance</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can add boilerplate code</li><li>👎🏻 May reduce flexibility if overused</li></ul>`
  },
  {
    "id": "polymorphism",
    "title": "Polymorphism",
    "icon": "https://img.icons8.com/?size=100&id=12157&format=png&color=000000",
    "description": "Polymorphism is the ability for objects of different classes to be treated as the same type, with the actual behavior of a function call determined by the specific class of the object passed in at runtime.",
    "anti-pattern": "Anti-pattern: Using type checks and manual dispatch instead of polymorphism.",
    "pros": ["Enables code reuse", "Simplifies code extension", "Supports flexible design"],
    "cons": ["Can make code harder to trace", "May introduce runtime errors if misused"],
    "details": `<h2>Polymorphism</h2>
      <p>Polymorphism is the ability in object-oriented programming (OOP) for different classes to be treated as instances of the same interface or parent class, allowing for method behavior to be determined dynamically based on the object's actual class.</p>
      <ul><li><strong>✅ Example:</strong> <br>
      <em>Animal</em> is an interface (or abstract class) with a <code>speak()</code> method. <em>Cat</em> and <em>Dog</em> are classes that implement the <em>Animal</em> interface and provide their own implementation of <code>speak()</code>.<br>
      A function <code>makeItSpeak(animal: Animal)</code> can accept either a <code>Cat</code> or <code>Dog</code> object at runtime, and will call the correct <code>speak()</code> method depending on the actual object passed in.<br>
      </li>
      <li><strong>❌ Anti-pattern:</strong> Using type checks and manual dispatch instead of polymorphism.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables code reuse</li><li>👍🏻 Simplifies code extension</li><li>👍🏻 Supports flexible design</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can make code harder to trace</li><li>👎🏻 May introduce runtime errors if misused</li></ul>`
  },
  {
    "id": "solidprinciples",
    "title": "SOLID Principles",
    "icon": "https://img.icons8.com/?size=100&id=20840&format=png&color=000000",
    "description": "Five fundamental principles for object-oriented programming and design that promote maintainable, flexible, and robust software architecture. These principles help developers write code that is easier to understand, modify, and extend.",
    "anti-pattern": "Anti-pattern: Writing monolithic classes that violate multiple SOLID principles, leading to tightly coupled, hard-to-maintain code.",
    "pros": ["Improves maintainability and readability", "Encourages separation of concerns and modularity", "Facilitates testing and debugging", "Reduces code duplication", "Makes code more flexible and extensible"],
    "cons": ["Can increase initial code complexity and development time", "May require more classes and interfaces", "Can lead to over-engineering if applied unnecessarily"],
    "details": `<h2>SOLID Principles</h2>
      <p>The SOLID principles are five fundamental design principles for object-oriented programming that promote maintainable, flexible, and robust software architecture. These principles, introduced by Robert C. Martin, help developers create code that is easier to understand, modify, and extend over time.</p>
      <ul><li><strong>✅ Example:</strong> A well-architected e-commerce system where each class has a single responsibility (SRP), payment processors can be extended without modification (OCP), different payment types are interchangeable (LSP), interfaces are focused and specific (ISP), and high-level modules depend on abstractions rather than concrete implementations (DIP).</li>
      <li><strong>❌ Anti-pattern:</strong> A monolithic 'OrderManager' class that handles order creation, payment processing, inventory management, email notifications, and logging - violating multiple SOLID principles and creating a maintenance nightmare.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves maintainability and readability</li><li>👍🏻 Encourages separation of concerns and modularity</li><li>👍🏻 Facilitates testing and debugging</li><li>👍🏻 Reduces code duplication</li><li>👍🏻 Makes code more flexible and extensible</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can increase initial code complexity and development time</li><li>👎🏻 May require more classes and interfaces</li><li>👎🏻 Can lead to over-engineering if applied unnecessarily</li></ul>`
  },
  {
    "id": "captheorem",
    "title": "CAP Theorem",
    "icon": "https://img.icons8.com/?size=100&id=12025&format=png&color=000000",
    "description": "In distributed systems, you can only guarantee two of: Consistency, Availability, Partition Tolerance. Example: CP system sacrifices availability during network partition.",
    "anti-pattern": "Anti-pattern: Assuming a distributed system can guarantee all three properties at once.",
    "pros": ["Clarifies trade-offs in distributed systems", "Guides architecture decisions"],
    "cons": ["Can oversimplify real-world systems", "Not all systems fit neatly into CAP categories"],
    "details": `<h2>CAP Theorem</h2>
      <p>In distributed systems, you can only guarantee two of: Consistency, Availability, Partition Tolerance.</p>
      <ul><li><strong>✅ Example:</strong> CP system sacrifices availability during network partition.</li>
      <li><strong>❌ Anti-pattern:</strong> Assuming a distributed system can guarantee all three properties at once.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Clarifies trade-offs in distributed systems</li><li>👍🏻 Guides architecture decisions</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can oversimplify real-world systems</li><li>👎🏻 Not all systems fit neatly into CAP categories</li></ul>`
  },
  {
    "id": "inheritance",
    "title": "Inheritance",
    "icon": "https://img.icons8.com/?size=100&id=DkpYfYRyotRl&format=png&color=000000",
    "description": "Mechanism to derive new classes from existing ones. Example: `class Car extends Vehicle {}` inherits attributes and methods.",
    "anti-pattern": "Anti-pattern: Copy-pasting code instead of using inheritance.",
    "pros": ["Promotes code reuse", "Simplifies extension of functionality"],
    "cons": ["Can lead to tight coupling", "May cause fragile base class problem"],
    "details": `<h2>Inheritance</h2>
      <p>Mechanism to derive new classes from existing ones.</p>
      <ul><li><strong>✅ Example:</strong> class Car extends Vehicle {} inherits attributes and methods.</li>
      <li><strong>❌ Anti-pattern:</strong> Copy-pasting code instead of using inheritance.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Promotes code reuse</li><li>👍🏻 Simplifies extension of functionality</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can lead to tight coupling</li><li>👎🏻 May cause fragile base class problem</li></ul>`
  },
  {
    "id": "microservices",
    "title": "Microservices",
    "icon": "https://img.icons8.com/?size=100&id=13052&format=png&color=000000",
    "description": "Architectural style that structures an app as a collection of loosely coupled services. Example: User service, order service, and payment service communicate via REST.",
    "anti-pattern": "Anti-pattern: A monolithic application where all logic is in a single codebase.",
    "pros": ["Enables independent deployment", "Improves scalability", "Facilitates technology diversity"],
    "cons": ["Increases operational complexity", "Requires robust inter-service communication", "Can lead to data consistency challenges"],
    "details": `<h2>Microservices</h2>
      <p>Architectural style that structures an app as a collection of loosely coupled services.</p>
      <ul><li><strong>✅ Example:</strong> User service, order service, and payment service communicate via REST.</li>
      <li><strong>❌ Anti-pattern:</strong> A monolithic application where all logic is in a single codebase.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables independent deployment</li><li>👍🏻 Improves scalability</li><li>👍🏻 Facilitates technology diversity</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Increases operational complexity</li><li>👎🏻 Requires robust inter-service communication</li><li>👎🏻 Can lead to data consistency challenges</li></ul>`
  },
  {
    "id": "domaindrivendesignddd",
    "title": "Domain-Driven Design (DDD)",
    "icon": "https://img.icons8.com/?size=100&id=12289&format=png&color=000000",
    "description": "Focuses on modeling software to match a domain's logic. Example: Bounded Contexts and Ubiquitous Language in large applications.",
    "anti-pattern": "Anti-pattern: Designing software without input from domain experts.",
    "pros": ["Aligns software with business needs", "Improves communication between developers and stakeholders"],
    "cons": ["Can be complex to implement", "Requires significant domain knowledge"],
    "details": `<h2>Domain-Driven Design (DDD)</h2>
      <p>Focuses on modeling software to match a domain's logic.</p>
      <ul><li><strong>✅ Example:</strong> Bounded Contexts and Ubiquitous Language in large applications.</li>
      <li><strong>❌ Anti-pattern:</strong> Designing software without input from domain experts.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Aligns software with business needs</li><li>👍🏻 Improves communication between developers and stakeholders</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can be complex to implement</li><li>👎🏻 Requires significant domain knowledge</li></ul>`
  },
  {
    "id": "kiss",
    "title": "KISS Principle",
    "icon": "https://img.icons8.com/?size=100&id=Nvl7OEzsGckV&format=png&color=000000",
    "description": "Keep It Simple, Stupid (KISS) emphasizes simplicity and clarity in software design and logic, helping avoid over-engineering and making code easier to read and maintain.",
    "anti-pattern": "Anti-pattern: Creating overly complex solutions for simple problems, adding unnecessary layers or abstractions.",
    "pros": ["Improves readability", "Reduces maintenance effort", "Minimizes bugs", "Speeds up development"],
    "cons": ["May oversimplify complex requirements", "Can ignore edge cases if too minimalistic"],
    "details": `<h2>KISS Principle</h2>
      <p>The KISS Principle stands for "Keep It Simple, Stupid" and encourages developers to write code that is simple, clear, and easy to understand. By focusing on simplicity, it helps avoid over-engineering and unnecessary complexity.</p>
      <ul><li><strong>✅ Example:</strong> Using straightforward logic and clear variable names instead of clever but confusing tricks.</li>
      <li><strong>❌ Anti-pattern:</strong> Creating overly complex solutions for simple problems, adding unnecessary layers or abstractions.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves readability</li><li>👍🏻 Reduces maintenance effort</li><li>👍🏻 Minimizes bugs</li><li>👍🏻 Speeds up development</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 May oversimplify complex requirements</li><li>👎🏻 Can ignore edge cases if too minimalistic</li></ul>`
  },
  {
    "id": "cleanarchitecture",
    "title": "Clean Architecture",
    "icon": "https://img.icons8.com/?size=100&id=12850&format=png&color=000000",
    "description": "Clean Architecture keeps business rules at the core, isolated from external concerns, making the codebase more robust, testable, and adaptable to change.",
    "anti-pattern": "Anti-pattern: Mixing business logic with infrastructure code, making changes risky and hard to test.",
    "pros": ["Improves testability", "Enhances maintainability", "Facilitates adaptability to change", "Promotes separation of concerns"],
    "cons": ["Can increase initial complexity", "Requires discipline in layering", "May need more upfront design"],
    "details": `<h2>Clean Architecture</h2>
      <p>Clean Architecture is a software design approach that places business rules and domain logic at the center of the application, keeping them isolated from frameworks, databases, and other external concerns. This separation makes the codebase more robust, testable, and adaptable to change.</p>
      <ul><li><strong>✅ Example:</strong> Business logic implemented in core domain classes, with infrastructure (UI, database, frameworks) depending on the core, not the other way around.</li>
      <li><strong>❌ Anti-pattern:</strong> Mixing business logic with infrastructure code, making changes risky and hard to test.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves testability</li><li>👍🏻 Enhances maintainability</li><li>👍🏻 Facilitates adaptability to change</li><li>👍🏻 Promotes separation of concerns</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can increase initial complexity</li><li>👎🏻 Requires discipline in layering</li><li>👎🏻 May need more upfront design</li></ul>`
  },
  {
    "id": "tdd",
    "title": "Test Driven Development (TDD)",
    "icon": "https://img.icons8.com/?size=100&id=42628&format=png&color=000000",
    "description": "Test Driven Development (TDD) is a software development process where tests are written before code, ensuring functionality and driving design decisions.",
    "anti-pattern": "Anti-pattern: Writing code first and adding tests later, leading to poor coverage and fragile code.",
    "pros": ["Improves code quality", "Ensures test coverage", "Facilitates refactoring", "Drives better design", "Reduces bugs"],
    "cons": ["Can slow initial development", "Requires discipline", "May lead to excessive tests for trivial code"],
    "details": `<h2>Test Driven Development (TDD)</h2>
      <p>Test Driven Development (TDD) is a software development approach where developers write automated tests before writing the actual code. The process follows a cycle: write a test, write code to pass the test, and refactor. This ensures that all functionality is covered by tests and helps drive design decisions.</p>
      <ul><li><strong>✅ Example:</strong> Writing a failing unit test for a new feature, then implementing the feature until the test passes, and finally refactoring the code while keeping all tests green.</li>
      <li><strong>❌ Anti-pattern:</strong> Writing code first and adding tests later, leading to poor coverage and fragile code.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves code quality</li><li>👍🏻 Ensures test coverage</li><li>👍🏻 Facilitates refactoring</li><li>👍🏻 Drives better design</li><li>👍🏻 Reduces bugs</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can slow initial development</li><li>👎🏻 Requires discipline</li><li>👎🏻 May lead to excessive tests for trivial code</li></ul>`
  },
  {
    "id": "eventdrivenarchitecture",
    "title": "Event-Driven Architecture",
    "icon": "https://img.icons8.com/?size=100&id=12817&format=png&color=000000",
    "description": "Event-Driven Architecture is a design paradigm where system components communicate by producing and consuming events, enabling loose coupling and real-time responsiveness.",
    "anti-pattern": "Anti-pattern: Tight coupling between components, direct calls instead of event notifications, making the system hard to scale and maintain.",
    "pros": ["Enables loose coupling", "Improves scalability", "Supports real-time processing", "Facilitates asynchronous communication"],
    "cons": ["Can increase system complexity", "Requires robust event management", "May make debugging harder"],
    "details": `<h2>Event-Driven Architecture</h2>
      <p>Event-Driven Architecture (EDA) is a software design paradigm where system components communicate by producing and consuming events. This approach enables loose coupling, scalability, and real-time responsiveness, as components react to events rather than direct calls.</p>
      <ul><li><strong>✅ Example:</strong> A payment service emits a 'PaymentProcessed' event, which is consumed by an email service to send a receipt and by an analytics service to update metrics.</li>
      <li><strong>❌ Anti-pattern:</strong> Tight coupling between components, direct calls instead of event notifications, making the system hard to scale and maintain.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables loose coupling</li><li>👍🏻 Improves scalability</li><li>👍🏻 Supports real-time processing</li><li>👍🏻 Facilitates asynchronous communication</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can increase system complexity</li><li>👎🏻 Requires robust event management</li><li>👎🏻 May make debugging harder</li></ul>`
  },
  {
    "id": "cqrs",
    "title": "Command Query Responsibility Segregation (CQRS)",
    "icon": "https://img.icons8.com/?size=100&id=NPxhzjDTqEjA&format=png&color=000000",
    "description": "CQRS separates read and write operations into distinct models, improving scalability, flexibility, and maintainability in complex systems.",
    "anti-pattern": "Anti-pattern: Using a single model for both reads and writes in complex domains, leading to performance bottlenecks and tangled logic.",
    "pros": ["Improves scalability", "Enables optimized queries", "Simplifies complex domains", "Facilitates event sourcing"],
    "cons": ["Adds architectural complexity", "Requires careful synchronization", "May be overkill for simple systems"],
    "details": `<h2>CQRS (Command Query Responsibility Segregation)</h2>
      <p>CQRS is an architectural pattern that separates the responsibilities of reading data (queries) and modifying data (commands) into distinct models. This separation allows each side to be optimized independently, improving scalability, flexibility, and maintainability in complex systems.</p>
      <ul><li><strong>✅ Example:</strong> Using one model to handle user commands (create, update, delete) and a separate model to handle queries for reporting or UI, each with its own data store or schema.</li>
      <li><strong>❌ Anti-pattern:</strong> Using a single model for both reads and writes in complex domains, leading to performance bottlenecks and tangled logic.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves scalability</li><li>👍🏻 Enables optimized queries</li><li>👍🏻 Simplifies complex domains</li><li>👍🏻 Facilitates event sourcing</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Adds architectural complexity</li><li>👎🏻 Requires careful synchronization</li><li>👎🏻 May be overkill for simple systems</li></ul>`
  },
  {
    "id": "concurrency",
    "title": "Concurrency",
    "icon": "https://img.icons8.com/?size=100&id=18688&format=png&color=000000",
    "description": "Concurrency is the ability of a system to execute multiple tasks simultaneously, requiring careful design to avoid race conditions and deadlocks.",
    "anti-pattern": "Anti-pattern: Ignoring synchronization, leading to race conditions or deadlocks when multiple threads access shared resources.",
    "pros": ["Improves performance", "Enables responsive systems", "Utilizes multi-core processors"],
    "cons": ["Can introduce complex bugs", "Requires careful synchronization", "May cause deadlocks or race conditions"],
    "details": `<h2>Concurrency</h2>
      <p>Concurrency is the ability of a system to execute multiple tasks simultaneously, often using threads or processes. While it can improve performance and responsiveness, it requires careful design to avoid issues like race conditions (unpredictable results from unsynchronized access) and deadlocks (tasks waiting forever for resources).</p>
      <ul><li><strong>✅ Example:</strong> Using locks, semaphores, or atomic operations to ensure only one thread updates a shared resource at a time, and designing resource acquisition order to avoid deadlocks.</li>
      <li><strong>❌ Anti-pattern:</strong> Ignoring synchronization, leading to race conditions or deadlocks when multiple threads access shared resources.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Improves performance</li><li>👍🏻 Enables responsive systems</li><li>👍🏻 Utilizes multi-core processors</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can introduce complex bugs</li><li>👎🏻 Requires careful synchronization</li><li>👎🏻 May cause deadlocks or race conditions</li></ul>`
  },
  {
    "id": "parallelism",
    "title": "Parallelism",
    "icon": "https://img.icons8.com/?size=100&id=13542&format=png&color=000000",
    "description": "Parallelism is the simultaneous execution of multiple tasks or computations, often to maximize resource utilization and speed up processing.",
    "anti-pattern": "Anti-pattern: Running parallel tasks without proper coordination, leading to resource contention, bottlenecks, or incorrect results.",
    "pros": ["Speeds up computation", "Utilizes hardware efficiently", "Handles large workloads"],
    "cons": ["Can be hard to debug", "May cause resource contention", "Requires careful design for correctness"],
    "details": `<h2>Parallelism</h2>
      <p>Parallelism is the simultaneous execution of multiple tasks or computations, typically across multiple CPU cores or machines. It is used to maximize resource utilization and speed up processing, especially for large or compute-intensive workloads.</p>
      <ul><li><strong>✅ Example:</strong> Processing large data sets by dividing the work among multiple threads or processes, each handling a portion of the data at the same time.</li>
      <li><strong>❌ Anti-pattern:</strong> Running parallel tasks without proper coordination, leading to resource contention, bottlenecks, or incorrect results.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Speeds up computation</li><li>👍🏻 Utilizes hardware efficiently</li><li>👍🏻 Handles large workloads</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can be hard to debug</li><li>👎🏻 May cause resource contention</li><li>👎🏻 Requires careful design for correctness</li></ul>`
  },
  {
    "id": "websockets",
    "title": "WebSockets",
    "icon": "https://img.icons8.com/?size=100&id=106729&format=png&color=000000",
    "description": "WebSockets provide full-duplex communication channels over a single TCP connection, enabling real-time, interactive applications like chat, gaming, and live dashboards.",
    "anti-pattern": "Anti-pattern: Using HTTP polling for real-time updates, causing unnecessary latency and server load.",
    "pros": ["Enables real-time communication", "Reduces latency", "Efficient use of resources", "Supports bidirectional data flow"],
    "cons": ["Requires persistent connection management", "May not be supported by all proxies/firewalls", "Can be more complex to scale"],
    "details": `<h2>WebSockets</h2>
      <p>WebSockets are a protocol that enables full-duplex, bidirectional communication between client and server over a single, long-lived TCP connection. This allows for real-time data exchange, making WebSockets ideal for applications like chat, gaming, collaborative editing, and live dashboards.</p>
      <ul><li><strong>✅ Example:</strong> A chat application where messages are instantly delivered to all connected users using WebSocket connections.</li>
      <li><strong>❌ Anti-pattern:</strong> Using HTTP polling for real-time updates, causing unnecessary latency and server load.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables real-time communication</li><li>👍🏻 Reduces latency</li><li>👍🏻 Efficient use of resources</li><li>👍🏻 Supports bidirectional data flow</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Requires persistent connection management</li><li>👎🏻 May not be supported by all proxies/firewalls</li><li>👎🏻 Can be more complex to scale</li></ul>`
  },
  {
    "id": "graphql",
    "title": "GraphQL",
    "icon": "https://img.icons8.com/?size=100&id=zdI5E8moxhs-&format=png&color=000000",
    "description": "GraphQL is a query language and runtime for APIs that enables clients to request exactly the data they need, reducing over-fetching and under-fetching compared to REST.",
    "anti-pattern": "Anti-pattern: Using REST endpoints for complex queries, resulting in multiple round-trips and over-fetching of data.",
    "pros": ["Flexible data retrieval", "Reduces over-fetching/under-fetching", "Single endpoint for all queries", "Strongly typed schema"],
    "cons": ["Requires schema design and maintenance", "Can expose too much data if not secured", "Complexity for simple use cases"],
    "details": `<h2>GraphQL</h2>
      <p>GraphQL is a query language and runtime for APIs that allows clients to specify exactly what data they need, and receive only that data in response. Unlike REST, which often requires multiple endpoints and can lead to over-fetching or under-fetching, GraphQL uses a single endpoint and a strongly typed schema to enable flexible, efficient data retrieval.</p>
      <ul><li><strong>✅ Example:</strong> A client requests only the user's name and email from a user profile, rather than the entire user object, using a GraphQL query.</li>
      <li><strong>❌ Anti-pattern:</strong> Using REST endpoints for complex queries, resulting in multiple round-trips and over-fetching of data.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Flexible data retrieval</li><li>👍🏻 Reduces over-fetching/under-fetching</li><li>👍🏻 Single endpoint for all queries</li><li>👍🏻 Strongly typed schema</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Requires schema design and maintenance</li><li>👎🏻 Can expose too much data if not secured</li><li>👎🏻 Complexity for simple use cases</li></ul>`
  },
  {
    "id": "grpc",
    "title": "gRPC",
    "icon": "https://img.icons8.com/?size=100&id=11903&format=png&color=000000",
    "description": "gRPC is a high-performance, open-source RPC framework that uses HTTP/2 and Protocol Buffers for efficient, strongly-typed communication between services, ideal for microservices and distributed systems.",
    "anti-pattern": "Anti-pattern: Using REST for high-frequency, low-latency service-to-service communication, resulting in unnecessary overhead and slower performance.",
    "pros": ["Efficient binary serialization", "Strongly typed contracts", "Supports streaming", "Built-in authentication and load balancing", "Cross-language support"],
    "cons": ["Requires Protocol Buffers schema", "Not human-readable payloads", "May be overkill for simple APIs", "Limited browser support"],
    "details": `<h2>gRPC</h2>
      <p>gRPC is a high-performance, open-source Remote Procedure Call (RPC) framework developed by Google. It uses HTTP/2 for transport, Protocol Buffers for efficient binary serialization, and provides strongly-typed contracts for communication between services. gRPC supports streaming, authentication, and load balancing, making it ideal for microservices and distributed systems.</p>
      <ul><li><strong>✅ Example:</strong> A microservices architecture where services communicate using gRPC for fast, efficient, and strongly-typed requests and responses.</li>
      <li><strong>❌ Anti-pattern:</strong> Using REST for high-frequency, low-latency service-to-service communication, resulting in unnecessary overhead and slower performance.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Efficient binary serialization</li><li>👍🏻 Strongly typed contracts</li><li>👍🏻 Supports streaming</li><li>👍🏻 Built-in authentication and load balancing</li><li>👍🏻 Cross-language support</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Requires Protocol Buffers schema</li><li>👎🏻 Not human-readable payloads</li><li>👎🏻 May be overkill for simple APIs</li><li>👎🏻 Limited browser support</li></ul>`
  },
  {
    "id": "webhook",
    "title": "Webhook",
    "icon": "https://img.icons8.com/?size=100&id=24459&format=png&color=000000",
    "description": "A webhook is a user-defined HTTP callback that allows one system to notify another system in real-time when an event occurs, enabling automation and integration between services.",
    "anti-pattern": "Anti-pattern: Polling for updates instead of using webhooks, causing unnecessary load and delayed responses.",
    "pros": ["Enables real-time notifications", "Reduces polling and server load", "Simplifies integration", "Automates workflows"],
    "cons": ["Requires endpoint security", "Can be hard to debug failures", "Dependent on network reliability", "May need retry logic"],
    "details": `<h2>Webhook</h2>
      <p>A webhook is a user-defined HTTP callback that allows one system to notify another system in real-time when a specific event occurs. Webhooks are commonly used to automate workflows and integrate services, such as triggering CI/CD pipelines, sending notifications, or updating external systems.</p>
      <ul><li><strong>✅ Example:</strong> A payment gateway sends a webhook to your server when a transaction is completed, allowing you to update order status instantly.</li>
      <li><strong>❌ Anti-pattern:</strong> Polling for updates instead of using webhooks, causing unnecessary load and delayed responses.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Enables real-time notifications</li><li>👍🏻 Reduces polling and server load</li><li>👍🏻 Simplifies integration</li><li>👍🏻 Automates workflows</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Requires endpoint security</li><li>👎🏻 Can be hard to debug failures</li><li>👎🏻 Dependent on network reliability</li><li>👎🏻 May need retry logic</li></ul>`
  },
  {
    "id": "restapi",
    "title": "REST API",
    "icon": "https://img.icons8.com/?size=100&id=21895&format=png&color=000000",
    "description": "A REST API is an architectural style for designing networked applications, using HTTP methods and stateless communication to expose resources as endpoints, widely used for web services.",
    "anti-pattern": "Anti-pattern: Ignoring HTTP conventions or using non-standard methods, leading to confusion and poor interoperability.",
    "pros": ["Simple and widely adopted", "Stateless and scalable", "Uses standard HTTP methods", "Language agnostic"],
    "cons": ["Can lead to over-fetching/under-fetching", "Limited for complex queries", "No built-in type safety", "May require multiple round-trips"],
    "details": `<h2>REST API</h2>
      <p>A REST API (Representational State Transfer) is an architectural style for designing networked applications. It uses standard HTTP methods (GET, POST, PUT, DELETE, etc.) to expose resources as endpoints, and relies on stateless communication between client and server. REST APIs are simple, scalable, and language agnostic, making them the most popular choice for web services.</p>
      <ul><li><strong>✅ Example:</strong> A web service exposes <code>/users</code> endpoint for GET (fetch users), POST (create user), PUT (update user), and DELETE (remove user) operations.</li>
      <li><strong>❌ Anti-pattern:</strong> Ignoring HTTP conventions or using non-standard methods, leading to confusion and poor interoperability.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Simple and widely adopted</li><li>👍🏻 Stateless and scalable</li><li>👍🏻 Uses standard HTTP methods</li><li>👍🏻 Language agnostic</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Can lead to over-fetching/under-fetching</li><li>👎🏻 Limited for complex queries</li><li>👎🏻 No built-in type safety</li><li>👎🏻 May require multiple round-trips</li></ul>`
  },
  {
    "id": "sse",
    "title": "Server Sent Events (SSE)",
    "icon": "https://img.icons8.com/?size=100&id=110286&format=png&color=000000",
    "description": "Server Sent Events (SSE) is a browser API for receiving automatic updates from a server via a single long-lived HTTP connection, ideal for real-time notifications and live data feeds.",
    "anti-pattern": "Anti-pattern: Using HTTP polling for real-time updates, causing unnecessary latency and server load.",
    "pros": ["Simple to implement for one-way updates", "Efficient for real-time notifications", "Built-in browser support", "Lightweight compared to WebSockets for one-way data"],
    "cons": ["One-way communication only (server to client)", "Limited browser support compared to WebSockets", "Not suitable for bidirectional data", "Connection limits in browsers"],
    "details": `<h2>Server Sent Events (SSE)</h2>
      <p>Server Sent Events (SSE) is a browser API that allows servers to push real-time updates to clients over a single long-lived HTTP connection. SSE is ideal for scenarios like live notifications, dashboards, or news feeds where the server needs to send data to the client as events occur.</p>
      <ul><li><strong>✅ Example:</strong> A stock ticker dashboard uses SSE to receive live price updates from the server, updating the UI instantly as new data arrives.</li>
      <li><strong>❌ Anti-pattern:</strong> Using HTTP polling for real-time updates, causing unnecessary latency and server load.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Simple to implement for one-way updates</li><li>👍🏻 Efficient for real-time notifications</li><li>👍🏻 Built-in browser support</li><li>👍🏻 Lightweight compared to WebSockets for one-way data</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 One-way communication only (server to client)</li><li>👎🏻 Limited browser support compared to WebSockets</li><li>👎🏻 Not suitable for bidirectional data</li><li>👎🏻 Connection limits in browsers</li></ul>`
  },
  {
    "id": "soap",
    "title": "Simple Object Access Protocol (SOAP)",
    "icon": "https://img.icons8.com/?size=100&id=13754&format=png&color=000000",
    "description": "SOAP is a protocol for exchanging structured information in web services using XML over HTTP, supporting strict standards, extensibility, and built-in error handling.",
    "anti-pattern": "Anti-pattern: Using SOAP for simple, lightweight APIs where REST or GraphQL would be more efficient and easier to implement.",
    "pros": ["Strict standards and specifications", "Built-in error handling and security", "Supports complex operations and transactions", "Language and platform agnostic", "Extensible via WS-* standards"],
    "cons": ["Verbose XML payloads", "Can be complex to implement and debug", "Slower than lightweight protocols", "Requires more tooling and configuration", "Less popular for modern web APIs"],
    "details": `<h2>SOAP (Simple Object Access Protocol)</h2>
      <p>SOAP is a protocol for exchanging structured information in web services, using XML as its message format and typically HTTP or SMTP as its transport. SOAP supports strict standards, extensibility, and built-in error handling, making it suitable for enterprise applications and complex integrations.</p>
      <ul><li><strong>✅ Example:</strong> An enterprise system uses SOAP to communicate between CRM and ERP platforms, ensuring reliable, secure, and standardized data exchange.</li>
      <li><strong>❌ Anti-pattern:</strong> Using SOAP for simple, lightweight APIs where REST or GraphQL would be more efficient and easier to implement.</li></ul>
      <strong>Pros:</strong><ul><li>👍🏻 Strict standards and specifications</li><li>👍🏻 Built-in error handling and security</li><li>👍🏻 Supports complex operations and transactions</li><li>👍🏻 Language and platform agnostic</li><li>👍🏻 Extensible via WS-* standards</li></ul>
      <strong>Cons:</strong><ul><li>👎🏻 Verbose XML payloads</li><li>👎🏻 Can be complex to implement and debug</li><li>👎🏻 Slower than lightweight protocols</li><li>👎🏻 Requires more tooling and configuration</li><li>👎🏻 Less popular for modern web APIs</li></ul>`
  }
];

    const solidPrinciples = [
  {
    id: "srp",
    title: "Single Responsibility Principle (SRP)",
    description: "A class should have only one reason to change, meaning it should have only one job or responsibility. This principle ensures that a class is focused on a single concern, making it easier to understand, test, and maintain.",
    example: "A 'UserEmailService' class that only handles sending emails to users. It doesn't manage user data, validate user input, or handle authentication - it has one clear responsibility: email communication.",
    counterExample: "A 'User' class that handles user data storage, email sending, password validation, logging, and file operations - having multiple reasons to change and multiple responsibilities.",
    pros: ["Easier to understand and maintain", "Improves code readability and organization", "Reduces the impact of changes", "Facilitates unit testing", "Promotes code reusability"],
    cons: ["May lead to more classes in the system", "Can sometimes be challenging to identify the 'single responsibility'", "Might increase initial development complexity"]
  },
  {
    id: "ocp",
    title: "Open/Closed Principle (OCP)",
    description: "Software entities (classes, modules, functions, etc.) should be open for extension but closed for modification. This means you should be able to add new functionality without changing existing code, typically achieved through inheritance, interfaces, or composition.",
    example: "A 'PaymentProcessor' abstract class with concrete implementations like 'CreditCardProcessor', 'PayPalProcessor', and 'CryptoProcessor'. Adding a new payment method (like 'ApplePayProcessor') doesn't require modifying existing payment classes.",
    counterExample: "A 'PaymentProcessor' class with a large switch statement that needs to be modified every time a new payment method is added, requiring changes to existing, tested code.",
    pros: ["Facilitates code extension without breaking existing functionality", "Reduces risk of introducing bugs in existing code", "Promotes loose coupling", "Supports the addition of new features safely", "Encourages the use of abstraction"],
    cons: ["Can require more abstraction and planning upfront", "May lead to more complex inheritance hierarchies", "Can be over-engineered if future requirements are unclear"]
  },
  {
    id: "lsp",
    title: "Liskov Substitution Principle (LSP)",
    description: "Subtypes must be substitutable for their base types without breaking the program. It means that objects of a superclass should be replaceable with objects of a subclass without breaking the application's functionality or violating expected behavior.",
    example: "A 'Bird' base class with a 'fly()' method, where 'Eagle' and 'Sparrow' subclasses can be used interchangeably anywhere a 'Bird' is expected, both implementing 'fly()' appropriately for their type without breaking the program's logic.",
    counterExample: "A 'Bird' base class with 'Penguin' subclass that throws an exception when 'fly()' is called, violating the expected behavior and breaking substitutability.",
    pros: ["Ensures correct inheritance design", "Prevents unexpected behavior when using polymorphism", "Maintains program correctness", "Enables reliable code reuse", "Supports robust object-oriented design"],
    cons: ["Can be subtle and difficult to enforce", "May require careful design of base class contracts", "Can limit flexibility in some inheritance scenarios"]
  },
  {
    id: "isp",
    title: "Interface Segregation Principle (ISP)",
    description: "Clients should not be forced to depend on interfaces they do not use. This principle advocates for creating specific, focused interfaces rather than large, monolithic ones. Classes should only implement the methods they actually need.",
    example: "Instead of one large 'Bird' interface with methods like 'fly()', 'swim()', and 'layEggs()', create separate interfaces: 'Flyable' with 'fly()', 'Swimmable' with 'swim()', and 'EggLayer' with 'layEggs()'. An 'Eagle' class implements 'Flyable' and 'EggLayer', while an 'Ostrich' class only implements 'EggLayer' (since ostriches can't fly or swim well).",
    counterExample: "A large 'Bird' interface that forces an 'Ostrich' class to implement unused methods like 'fly()' and 'swim()', typically resulting in empty implementations or thrown exceptions since ostriches cannot fly or swim effectively.",
    pros: ["Reduces unnecessary dependencies", "Improves code flexibility and maintainability", "Makes interfaces more focused and cohesive", "Enables better testability", "Prevents interface pollution"],
    cons: ["May result in more interfaces to manage", "Can increase the number of dependencies", "Requires careful interface design planning"]
  },
  {
    id: "dip",
    title: "Dependency Inversion Principle (DIP)",
    description: "High-level modules should not depend on low-level modules. Both should depend on abstractions (interfaces or abstract classes). Additionally, abstractions should not depend on details; details should depend on abstractions. This principle promotes loose coupling and makes systems more flexible and testable.",
    example: "An 'OrderService' class depends on an 'IPaymentProcessor' interface rather than a concrete 'CreditCardProcessor' class. The payment processor implementation is injected, allowing easy switching between different payment methods without changing the OrderService code.",
    counterExample: "An 'OrderService' class that directly instantiates and uses a 'CreditCardProcessor' class, creating tight coupling and making it difficult to test or switch to different payment processors.",
    pros: ["Improves testability through dependency injection", "Reduces coupling between modules", "Increases flexibility and extensibility", "Makes code more modular and maintainable", "Enables easier mocking for unit tests"],
    cons: ["Can add complexity to the system architecture", "May require dependency injection frameworks", "Can make code harder to follow for beginners", "Requires more upfront design consideration"]
  }
];

    const dddSubtopics = [
  {
    id: "bounded-context",
    title: "Bounded Context",
    description: "A boundary within which a particular domain model is defined and applicable.",
    example: "User and Order are separate bounded contexts in an e-commerce system.",
    counterExample: "Mixing unrelated models and logic in a single context.",
    pros: ["Reduces ambiguity", "Enables independent development"],
    cons: ["Requires clear boundaries", "Can add integration complexity"]
  },
  {
    id: "ubiquitous-language",
    title: "Ubiquitous Language",
    description: "A common language used by both developers and domain experts to describe the domain.",
    example: "Using the same terms for concepts in code and business discussions.",
    counterExample: "Developers and business use different terms for the same concept.",
    pros: ["Improves communication", "Reduces misunderstandings"],
    cons: ["Requires discipline to maintain"]
  },
  {
    id: "entity",
    title: "Entity",
    description: "An object defined primarily by its identity, not its attributes.",
    example: "A Customer object with a unique ID.",
    counterExample: "Treating objects with no unique identity as entities.",
    pros: ["Tracks changes over time", "Supports complex domains"],
    cons: ["Can be overused for simple data"]
  },
  {
    id: "value-object",
    title: "Value Object",
    description: "An object defined by its attributes, not its identity.",
    example: "An Address object with street, city, and zip code.",
    counterExample: "Assigning unique IDs to value objects.",
    pros: ["Immutable", "Easier to reason about"],
    cons: ["May require copying for changes"]
  },
  {
    id: "aggregate",
    title: "Aggregate",
    description: "A cluster of domain objects treated as a single unit for data changes.",
    example: "Order aggregate includes Order and OrderItems.",
    counterExample: "Allowing external objects to modify aggregate internals directly.",
    pros: ["Enforces consistency", "Defines clear ownership"],
    cons: ["Can be complex to design"]
  },
  {
    id: "repository",
    title: "Repository",
    description: "A mechanism for encapsulating storage, retrieval, and search behavior.",
    example: "OrderRepository handles saving and retrieving Order aggregates.",
    counterExample: "Directly accessing the database from domain logic.",
    pros: ["Decouples domain from data access", "Improves testability"],
    cons: ["Adds abstraction layer"]
  }
];

    function renderCards() {
      const container = document.getElementById('card-container');
      container.innerHTML = concepts.map(c => `
        <div class="card" onclick="showModal('${c.id}')">
          <img class="icon" src="${c.icon}" alt="${c.title}" />
          <div class="title">${c.title}</div>
          <div class="description">${c.description.replace(/\n/g, '<br>')}</div>
        </div>`).join('');
    }

    function showSolidPrincipleModal(principleId) {
  const p = solidPrinciples.find(x => x.id === principleId);
  if (p) {
    modalBody.innerHTML = `
      <h2>${p.title}</h2>
      <p>${p.description}</p>
      <ul><li><strong>✅ Example:</strong> ${p.example}</li>
      <li><strong>❌ Anti-pattern:</strong> ${p.counterExample}</li></ul>
      <strong>Pros:</strong><ul>${p.pros.map(pr => `<li>👍🏻 ${pr}</li>`).join('')}</ul>
      <strong>Cons:</strong><ul>${p.cons.map(co => `<li>👎🏻 ${co}</li>`).join('')}</ul>
      <button onclick="showModal('solidprinciples')">Back to SOLID Principles</button>
    `;
    modal.style.display = 'flex';
  }
}

    function showDDDSubtopicModal(subtopicId) {
  const s = dddSubtopics.find(x => x.id === subtopicId);
  if (s) {
    modalBody.innerHTML = `
      <h2>${s.title}</h2>
      <p>${s.description}</p>
      <ul><li><strong>✅ Example:</strong> ${s.example}</li>
      <li><strong>❌ Anti-pattern:</strong> ${s.counterExample}</li></ul>
      <strong>Pros:</strong><ul>${s.pros.map(pr => `<li>👍🏻 ${pr}</li>`).join('')}</ul>
      <strong>Cons:</strong><ul>${s.cons.map(co => `<li>👎🏻 ${co}</li>`).join('')}</ul>
      <button onclick=\"showModal('domaindrivendesignddd')\">Back to DDD</button>
    `;
    modal.style.display = 'flex';
  }
}

    function showModal(id) {
      if (id === 'solidprinciples') {
        modalBody.innerHTML = `
      <h2>SOLID Principles</h2>
      <p>Five principles for maintainable OOP: SRP, OCP, LSP, ISP, DIP.</p>
      <ul>
        <li><a href="#" onclick="showSolidPrincipleModal('srp');return false;">Single Responsibility Principle (SRP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('ocp');return false;">Open/Closed Principle (OCP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('lsp');return false;">Liskov Substitution Principle (LSP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('isp');return false;">Interface Segregation Principle (ISP)</a></li>
        <li><a href="#" onclick="showSolidPrincipleModal('dip');return false;">Dependency Inversion Principle (DIP)</a></li>
      </ul>
    `;
        modal.style.display = 'flex';
        return;
      }
      if (id === 'domaindrivendesignddd') {
        modalBody.innerHTML = `
      <h2>Domain-Driven Design (DDD)</h2>
      <p>Focuses on modeling software to match a domain's logic. Key subtopics:</p>
      <ul>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('bounded-context');return false;\">Bounded Context</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('ubiquitous-language');return false;\">Ubiquitous Language</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('entity');return false;\">Entity</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('value-object');return false;\">Value Object</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('aggregate');return false;\">Aggregate</a></li>
        <li><a href=\"#\" onclick=\"showDDDSubtopicModal('repository');return false;\">Repository</a></li>
      </ul>
    `;
        modal.style.display = 'flex';
        return;
      }
      const concept = concepts.find(c => c.id === id);
      if (concept) {
        modalBody.innerHTML = concept.details;
        modal.style.display = 'flex';
      }
    }

    function closeModal() {
      modal.style.display = 'none';
    }

    window.onclick = function(event) {
      if (event.target === modal) {
        closeModal();
      }
    }

    renderCards();
  </script>
</body>
</html>
